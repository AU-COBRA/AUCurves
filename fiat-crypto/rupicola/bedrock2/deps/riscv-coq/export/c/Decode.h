// This C file was autogenerated from Coq
#include <stdbool.h>
#include <stdint.h>

#define Register int

#define Opcode int

typedef enum {RV32I, RV32IM, RV32IA, RV32IMA, RV64I, RV64IM, RV64IA, RV64IMA} InstructionSet;

typedef enum {K_Mulw, K_Divw, K_Divuw, K_Remw, K_Remuw, K_InvalidM64} InstructionM64_kind;

typedef struct {
    InstructionM64_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mulw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Divw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Divuw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Remw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Remuw;
        struct {
        } as_InvalidM64;
    };
} InstructionM64;

InstructionM64 Mulw(Register f_0, Register f_1, Register f_2) {
    InstructionM64 res = {K_Mulw, { .as_Mulw = {f_0, f_1, f_2} } };
    return res;
}

InstructionM64 Divw(Register f_0, Register f_1, Register f_2) {
    InstructionM64 res = {K_Divw, { .as_Divw = {f_0, f_1, f_2} } };
    return res;
}

InstructionM64 Divuw(Register f_0, Register f_1, Register f_2) {
    InstructionM64 res = {K_Divuw, { .as_Divuw = {f_0, f_1, f_2} } };
    return res;
}

InstructionM64 Remw(Register f_0, Register f_1, Register f_2) {
    InstructionM64 res = {K_Remw, { .as_Remw = {f_0, f_1, f_2} } };
    return res;
}

InstructionM64 Remuw(Register f_0, Register f_1, Register f_2) {
    InstructionM64 res = {K_Remuw, { .as_Remuw = {f_0, f_1, f_2} } };
    return res;
}

InstructionM64 InvalidM64() {
    InstructionM64 res = {K_InvalidM64, { .as_InvalidM64 = {} } };
    return res;
}

typedef enum {K_Mul, K_Mulh, K_Mulhsu, K_Mulhu, K_Div, K_Divu, K_Rem, K_Remu, K_InvalidM} InstructionM_kind;

typedef struct {
    InstructionM_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mul;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mulh;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mulhsu;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mulhu;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Div;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Divu;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Rem;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Remu;
        struct {
        } as_InvalidM;
    };
} InstructionM;

InstructionM Mul(Register f_0, Register f_1, Register f_2) {
    InstructionM res = {K_Mul, { .as_Mul = {f_0, f_1, f_2} } };
    return res;
}

InstructionM Mulh(Register f_0, Register f_1, Register f_2) {
    InstructionM res = {K_Mulh, { .as_Mulh = {f_0, f_1, f_2} } };
    return res;
}

InstructionM Mulhsu(Register f_0, Register f_1, Register f_2) {
    InstructionM res = {K_Mulhsu, { .as_Mulhsu = {f_0, f_1, f_2} } };
    return res;
}

InstructionM Mulhu(Register f_0, Register f_1, Register f_2) {
    InstructionM res = {K_Mulhu, { .as_Mulhu = {f_0, f_1, f_2} } };
    return res;
}

InstructionM Div(Register f_0, Register f_1, Register f_2) {
    InstructionM res = {K_Div, { .as_Div = {f_0, f_1, f_2} } };
    return res;
}

InstructionM Divu(Register f_0, Register f_1, Register f_2) {
    InstructionM res = {K_Divu, { .as_Divu = {f_0, f_1, f_2} } };
    return res;
}

InstructionM Rem(Register f_0, Register f_1, Register f_2) {
    InstructionM res = {K_Rem, { .as_Rem = {f_0, f_1, f_2} } };
    return res;
}

InstructionM Remu(Register f_0, Register f_1, Register f_2) {
    InstructionM res = {K_Remu, { .as_Remu = {f_0, f_1, f_2} } };
    return res;
}

InstructionM InvalidM() {
    InstructionM res = {K_InvalidM, { .as_InvalidM = {} } };
    return res;
}

typedef enum {K_Ld, K_Lwu, K_Addiw, K_Slliw, K_Srliw, K_Sraiw, K_Sd, K_Addw, K_Subw, K_Sllw, K_Srlw, K_Sraw, K_InvalidI64} InstructionI64_kind;

typedef struct {
    InstructionI64_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Ld;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lwu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Addiw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Slliw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Srliw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sraiw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sd;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Addw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Subw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sllw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Srlw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sraw;
        struct {
        } as_InvalidI64;
    };
} InstructionI64;

InstructionI64 Ld(Register f_0, Register f_1, int f_2) {
    InstructionI64 res = {K_Ld, { .as_Ld = {f_0, f_1, f_2} } };
    return res;
}

InstructionI64 Lwu(Register f_0, Register f_1, int f_2) {
    InstructionI64 res = {K_Lwu, { .as_Lwu = {f_0, f_1, f_2} } };
    return res;
}

InstructionI64 Addiw(Register f_0, Register f_1, int f_2) {
    InstructionI64 res = {K_Addiw, { .as_Addiw = {f_0, f_1, f_2} } };
    return res;
}

InstructionI64 Slliw(Register f_0, Register f_1, int f_2) {
    InstructionI64 res = {K_Slliw, { .as_Slliw = {f_0, f_1, f_2} } };
    return res;
}

InstructionI64 Srliw(Register f_0, Register f_1, int f_2) {
    InstructionI64 res = {K_Srliw, { .as_Srliw = {f_0, f_1, f_2} } };
    return res;
}

InstructionI64 Sraiw(Register f_0, Register f_1, int f_2) {
    InstructionI64 res = {K_Sraiw, { .as_Sraiw = {f_0, f_1, f_2} } };
    return res;
}

InstructionI64 Sd(Register f_0, Register f_1, int f_2) {
    InstructionI64 res = {K_Sd, { .as_Sd = {f_0, f_1, f_2} } };
    return res;
}

InstructionI64 Addw(Register f_0, Register f_1, Register f_2) {
    InstructionI64 res = {K_Addw, { .as_Addw = {f_0, f_1, f_2} } };
    return res;
}

InstructionI64 Subw(Register f_0, Register f_1, Register f_2) {
    InstructionI64 res = {K_Subw, { .as_Subw = {f_0, f_1, f_2} } };
    return res;
}

InstructionI64 Sllw(Register f_0, Register f_1, Register f_2) {
    InstructionI64 res = {K_Sllw, { .as_Sllw = {f_0, f_1, f_2} } };
    return res;
}

InstructionI64 Srlw(Register f_0, Register f_1, Register f_2) {
    InstructionI64 res = {K_Srlw, { .as_Srlw = {f_0, f_1, f_2} } };
    return res;
}

InstructionI64 Sraw(Register f_0, Register f_1, Register f_2) {
    InstructionI64 res = {K_Sraw, { .as_Sraw = {f_0, f_1, f_2} } };
    return res;
}

InstructionI64 InvalidI64() {
    InstructionI64 res = {K_InvalidI64, { .as_InvalidI64 = {} } };
    return res;
}

typedef enum {K_Lb, K_Lh, K_Lw, K_Lbu, K_Lhu, K_Fence, K_Fence_i, K_Addi, K_Slli, K_Slti, K_Sltiu, K_Xori, K_Ori, K_Andi, K_Srli, K_Srai, K_Auipc, K_Sb, K_Sh, K_Sw, K_Add, K_Sub, K_Sll, K_Slt, K_Sltu, K_Xor, K_Srl, K_Sra, K_Or, K_And, K_Lui, K_Beq, K_Bne, K_Blt, K_Bge, K_Bltu, K_Bgeu, K_Jalr, K_Jal, K_InvalidI} InstructionI_kind;

typedef struct {
    InstructionI_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lb;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lh;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lbu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lhu;
        struct {
            int f0;
            int f1;
        } as_Fence;
        struct {
        } as_Fence_i;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Addi;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Slli;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Slti;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sltiu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Xori;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Ori;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Andi;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Srli;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Srai;
        struct {
            Register f0;
            int f1;
        } as_Auipc;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sb;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sh;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Add;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sub;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sll;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Slt;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sltu;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Xor;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Srl;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sra;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Or;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_And;
        struct {
            Register f0;
            int f1;
        } as_Lui;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Beq;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Bne;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Blt;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Bge;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Bltu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Bgeu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Jalr;
        struct {
            Register f0;
            int f1;
        } as_Jal;
        struct {
        } as_InvalidI;
    };
} InstructionI;

InstructionI Lb(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Lb, { .as_Lb = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Lh(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Lh, { .as_Lh = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Lw(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Lw, { .as_Lw = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Lbu(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Lbu, { .as_Lbu = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Lhu(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Lhu, { .as_Lhu = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Fence(int f_0, int f_1) {
    InstructionI res = {K_Fence, { .as_Fence = {f_0, f_1} } };
    return res;
}

InstructionI Fence_i() {
    InstructionI res = {K_Fence_i, { .as_Fence_i = {} } };
    return res;
}

InstructionI Addi(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Addi, { .as_Addi = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Slli(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Slli, { .as_Slli = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Slti(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Slti, { .as_Slti = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Sltiu(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Sltiu, { .as_Sltiu = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Xori(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Xori, { .as_Xori = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Ori(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Ori, { .as_Ori = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Andi(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Andi, { .as_Andi = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Srli(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Srli, { .as_Srli = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Srai(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Srai, { .as_Srai = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Auipc(Register f_0, int f_1) {
    InstructionI res = {K_Auipc, { .as_Auipc = {f_0, f_1} } };
    return res;
}

InstructionI Sb(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Sb, { .as_Sb = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Sh(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Sh, { .as_Sh = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Sw(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Sw, { .as_Sw = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Add(Register f_0, Register f_1, Register f_2) {
    InstructionI res = {K_Add, { .as_Add = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Sub(Register f_0, Register f_1, Register f_2) {
    InstructionI res = {K_Sub, { .as_Sub = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Sll(Register f_0, Register f_1, Register f_2) {
    InstructionI res = {K_Sll, { .as_Sll = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Slt(Register f_0, Register f_1, Register f_2) {
    InstructionI res = {K_Slt, { .as_Slt = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Sltu(Register f_0, Register f_1, Register f_2) {
    InstructionI res = {K_Sltu, { .as_Sltu = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Xor(Register f_0, Register f_1, Register f_2) {
    InstructionI res = {K_Xor, { .as_Xor = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Srl(Register f_0, Register f_1, Register f_2) {
    InstructionI res = {K_Srl, { .as_Srl = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Sra(Register f_0, Register f_1, Register f_2) {
    InstructionI res = {K_Sra, { .as_Sra = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Or(Register f_0, Register f_1, Register f_2) {
    InstructionI res = {K_Or, { .as_Or = {f_0, f_1, f_2} } };
    return res;
}

InstructionI And(Register f_0, Register f_1, Register f_2) {
    InstructionI res = {K_And, { .as_And = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Lui(Register f_0, int f_1) {
    InstructionI res = {K_Lui, { .as_Lui = {f_0, f_1} } };
    return res;
}

InstructionI Beq(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Beq, { .as_Beq = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Bne(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Bne, { .as_Bne = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Blt(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Blt, { .as_Blt = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Bge(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Bge, { .as_Bge = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Bltu(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Bltu, { .as_Bltu = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Bgeu(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Bgeu, { .as_Bgeu = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Jalr(Register f_0, Register f_1, int f_2) {
    InstructionI res = {K_Jalr, { .as_Jalr = {f_0, f_1, f_2} } };
    return res;
}

InstructionI Jal(Register f_0, int f_1) {
    InstructionI res = {K_Jal, { .as_Jal = {f_0, f_1} } };
    return res;
}

InstructionI InvalidI() {
    InstructionI res = {K_InvalidI, { .as_InvalidI = {} } };
    return res;
}

typedef enum {K_Ecall, K_Ebreak, K_Uret, K_Sret, K_Mret, K_Wfi, K_Sfence_vma, K_Csrrw, K_Csrrs, K_Csrrc, K_Csrrwi, K_Csrrsi, K_Csrrci, K_InvalidCSR} InstructionCSR_kind;

typedef struct {
    InstructionCSR_kind kind;
    union {
        struct {
        } as_Ecall;
        struct {
        } as_Ebreak;
        struct {
        } as_Uret;
        struct {
        } as_Sret;
        struct {
        } as_Mret;
        struct {
        } as_Wfi;
        struct {
            Register f0;
            Register f1;
        } as_Sfence_vma;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Csrrw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Csrrs;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Csrrc;
        struct {
            Register f0;
            int f1;
            int f2;
        } as_Csrrwi;
        struct {
            Register f0;
            int f1;
            int f2;
        } as_Csrrsi;
        struct {
            Register f0;
            int f1;
            int f2;
        } as_Csrrci;
        struct {
        } as_InvalidCSR;
    };
} InstructionCSR;

InstructionCSR Ecall() {
    InstructionCSR res = {K_Ecall, { .as_Ecall = {} } };
    return res;
}

InstructionCSR Ebreak() {
    InstructionCSR res = {K_Ebreak, { .as_Ebreak = {} } };
    return res;
}

InstructionCSR Uret() {
    InstructionCSR res = {K_Uret, { .as_Uret = {} } };
    return res;
}

InstructionCSR Sret() {
    InstructionCSR res = {K_Sret, { .as_Sret = {} } };
    return res;
}

InstructionCSR Mret() {
    InstructionCSR res = {K_Mret, { .as_Mret = {} } };
    return res;
}

InstructionCSR Wfi() {
    InstructionCSR res = {K_Wfi, { .as_Wfi = {} } };
    return res;
}

InstructionCSR Sfence_vma(Register f_0, Register f_1) {
    InstructionCSR res = {K_Sfence_vma, { .as_Sfence_vma = {f_0, f_1} } };
    return res;
}

InstructionCSR Csrrw(Register f_0, Register f_1, int f_2) {
    InstructionCSR res = {K_Csrrw, { .as_Csrrw = {f_0, f_1, f_2} } };
    return res;
}

InstructionCSR Csrrs(Register f_0, Register f_1, int f_2) {
    InstructionCSR res = {K_Csrrs, { .as_Csrrs = {f_0, f_1, f_2} } };
    return res;
}

InstructionCSR Csrrc(Register f_0, Register f_1, int f_2) {
    InstructionCSR res = {K_Csrrc, { .as_Csrrc = {f_0, f_1, f_2} } };
    return res;
}

InstructionCSR Csrrwi(Register f_0, int f_1, int f_2) {
    InstructionCSR res = {K_Csrrwi, { .as_Csrrwi = {f_0, f_1, f_2} } };
    return res;
}

InstructionCSR Csrrsi(Register f_0, int f_1, int f_2) {
    InstructionCSR res = {K_Csrrsi, { .as_Csrrsi = {f_0, f_1, f_2} } };
    return res;
}

InstructionCSR Csrrci(Register f_0, int f_1, int f_2) {
    InstructionCSR res = {K_Csrrci, { .as_Csrrci = {f_0, f_1, f_2} } };
    return res;
}

InstructionCSR InvalidCSR() {
    InstructionCSR res = {K_InvalidCSR, { .as_InvalidCSR = {} } };
    return res;
}

typedef enum {K_Lr_d, K_Sc_d, K_Amoswap_d, K_Amoadd_d, K_Amoand_d, K_Amoor_d, K_Amoxor_d, K_Amomax_d, K_Amomaxu_d, K_Amomin_d, K_Amominu_d, K_InvalidA64} InstructionA64_kind;

typedef struct {
    InstructionA64_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lr_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Sc_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoswap_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoadd_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoand_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoor_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoxor_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomax_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomaxu_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomin_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amominu_d;
        struct {
        } as_InvalidA64;
    };
} InstructionA64;

InstructionA64 Lr_d(Register f_0, Register f_1, int f_2) {
    InstructionA64 res = {K_Lr_d, { .as_Lr_d = {f_0, f_1, f_2} } };
    return res;
}

InstructionA64 Sc_d(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA64 res = {K_Sc_d, { .as_Sc_d = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA64 Amoswap_d(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA64 res = {K_Amoswap_d, { .as_Amoswap_d = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA64 Amoadd_d(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA64 res = {K_Amoadd_d, { .as_Amoadd_d = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA64 Amoand_d(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA64 res = {K_Amoand_d, { .as_Amoand_d = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA64 Amoor_d(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA64 res = {K_Amoor_d, { .as_Amoor_d = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA64 Amoxor_d(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA64 res = {K_Amoxor_d, { .as_Amoxor_d = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA64 Amomax_d(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA64 res = {K_Amomax_d, { .as_Amomax_d = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA64 Amomaxu_d(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA64 res = {K_Amomaxu_d, { .as_Amomaxu_d = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA64 Amomin_d(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA64 res = {K_Amomin_d, { .as_Amomin_d = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA64 Amominu_d(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA64 res = {K_Amominu_d, { .as_Amominu_d = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA64 InvalidA64() {
    InstructionA64 res = {K_InvalidA64, { .as_InvalidA64 = {} } };
    return res;
}

typedef enum {K_Lr_w, K_Sc_w, K_Amoswap_w, K_Amoadd_w, K_Amoand_w, K_Amoor_w, K_Amoxor_w, K_Amomax_w, K_Amomaxu_w, K_Amomin_w, K_Amominu_w, K_InvalidA} InstructionA_kind;

typedef struct {
    InstructionA_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lr_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Sc_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoswap_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoadd_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoand_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoor_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoxor_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomax_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomaxu_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomin_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amominu_w;
        struct {
        } as_InvalidA;
    };
} InstructionA;

InstructionA Lr_w(Register f_0, Register f_1, int f_2) {
    InstructionA res = {K_Lr_w, { .as_Lr_w = {f_0, f_1, f_2} } };
    return res;
}

InstructionA Sc_w(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA res = {K_Sc_w, { .as_Sc_w = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA Amoswap_w(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA res = {K_Amoswap_w, { .as_Amoswap_w = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA Amoadd_w(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA res = {K_Amoadd_w, { .as_Amoadd_w = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA Amoand_w(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA res = {K_Amoand_w, { .as_Amoand_w = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA Amoor_w(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA res = {K_Amoor_w, { .as_Amoor_w = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA Amoxor_w(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA res = {K_Amoxor_w, { .as_Amoxor_w = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA Amomax_w(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA res = {K_Amomax_w, { .as_Amomax_w = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA Amomaxu_w(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA res = {K_Amomaxu_w, { .as_Amomaxu_w = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA Amomin_w(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA res = {K_Amomin_w, { .as_Amomin_w = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA Amominu_w(Register f_0, Register f_1, Register f_2, int f_3) {
    InstructionA res = {K_Amominu_w, { .as_Amominu_w = {f_0, f_1, f_2, f_3} } };
    return res;
}

InstructionA InvalidA() {
    InstructionA res = {K_InvalidA, { .as_InvalidA = {} } };
    return res;
}

typedef enum {K_IInstruction, K_MInstruction, K_AInstruction, K_I64Instruction, K_M64Instruction, K_A64Instruction, K_CSRInstruction, K_InvalidInstruction} Instruction_kind;

typedef struct {
    Instruction_kind kind;
    union {
        struct {
            InstructionI f0;
        } as_IInstruction;
        struct {
            InstructionM f0;
        } as_MInstruction;
        struct {
            InstructionA f0;
        } as_AInstruction;
        struct {
            InstructionI64 f0;
        } as_I64Instruction;
        struct {
            InstructionM64 f0;
        } as_M64Instruction;
        struct {
            InstructionA64 f0;
        } as_A64Instruction;
        struct {
            InstructionCSR f0;
        } as_CSRInstruction;
        struct {
            int f0;
        } as_InvalidInstruction;
    };
} Instruction;

Instruction IInstruction(InstructionI f_0) {
    Instruction res = {K_IInstruction, { .as_IInstruction = {f_0} } };
    return res;
}

Instruction MInstruction(InstructionM f_0) {
    Instruction res = {K_MInstruction, { .as_MInstruction = {f_0} } };
    return res;
}

Instruction AInstruction(InstructionA f_0) {
    Instruction res = {K_AInstruction, { .as_AInstruction = {f_0} } };
    return res;
}

Instruction I64Instruction(InstructionI64 f_0) {
    Instruction res = {K_I64Instruction, { .as_I64Instruction = {f_0} } };
    return res;
}

Instruction M64Instruction(InstructionM64 f_0) {
    Instruction res = {K_M64Instruction, { .as_M64Instruction = {f_0} } };
    return res;
}

Instruction A64Instruction(InstructionA64 f_0) {
    Instruction res = {K_A64Instruction, { .as_A64Instruction = {f_0} } };
    return res;
}

Instruction CSRInstruction(InstructionCSR f_0) {
    Instruction res = {K_CSRInstruction, { .as_CSRInstruction = {f_0} } };
    return res;
}

Instruction InvalidInstruction(int f_0) {
    Instruction res = {K_InvalidInstruction, { .as_InvalidInstruction = {f_0} } };
    return res;
}


typedef struct {
    Instruction inst;
    int size;
} InstructionList;

InstructionList empty_instruction_list() {
    InstructionList res = { InvalidInstruction(0), 0 };
    return res;
}

InstructionList singleton_instruction_list(Instruction i) {
    InstructionList res = { i, 1 };
    return res;
}

InstructionList concat_instruction_list(InstructionList l1, InstructionList l2) {
    if (l1.size == 0) {
        return l2;
    }
    if (l2.size == 0) {
        return l1;
    }
    InstructionList res = { InvalidInstruction(0), 2 }; // 2 means "more than 1"
    return res;
}

Instruction instruction_list_head_default(InstructionList l, Instruction deflt) {
    if (l.size == 1) {
        return l.inst;
    } else {
        return deflt;
    }
}

int bitwidth(InstructionSet arg_0__) {
    switch (arg_0__) {
        case RV32I:
            return 0b100000;
        case RV32IM:
            return 0b100000;
        case RV32IA:
            return 0b100000;
        case RV32IMA:
            return 0b100000;
        default:
            return 0b1000000;
    }
}

#define funct12_EBREAK 0b1

#define funct12_ECALL 0b0

#define funct12_MRET 0b1100000010

#define funct12_SRET 0b100000010

#define funct12_URET 0b10

#define funct12_WFI 0b100000101

#define funct3_ADD 0b0

#define funct3_ADDI 0b0

#define funct3_ADDIW 0b0

#define funct3_ADDW 0b0

#define funct3_AMOD 0b11

#define funct3_AMOW 0b10

#define funct3_AND 0b111

#define funct3_ANDI 0b111

#define funct3_BEQ 0b0

#define funct3_BGE 0b101

#define funct3_BGEU 0b111

#define funct3_BLT 0b100

#define funct3_BLTU 0b110

#define funct3_BNE 0b1

#define funct3_CSRRC 0b11

#define funct3_CSRRCI 0b111

#define funct3_CSRRS 0b10

#define funct3_CSRRSI 0b110

#define funct3_CSRRW 0b1

#define funct3_CSRRWI 0b101

#define funct3_DIV 0b100

#define funct3_DIVU 0b101

#define funct3_DIVUW 0b101

#define funct3_DIVW 0b100

#define funct3_FENCE 0b0

#define funct3_FENCE_I 0b1

#define funct3_LB 0b0

#define funct3_LBU 0b100

#define funct3_LD 0b11

#define funct3_LH 0b1

#define funct3_LHU 0b101

#define funct3_LW 0b10

#define funct3_LWU 0b110

#define funct3_MUL 0b0

#define funct3_MULH 0b1

#define funct3_MULHSU 0b10

#define funct3_MULHU 0b11

#define funct3_MULW 0b0

#define funct3_OR 0b110

#define funct3_ORI 0b110

#define funct3_PRIV 0b0

#define funct3_REM 0b110

#define funct3_REMU 0b111

#define funct3_REMUW 0b111

#define funct3_REMW 0b110

#define funct3_SB 0b0

#define funct3_SD 0b11

#define funct3_SH 0b1

#define funct3_SLL 0b1

#define funct3_SLLI 0b1

#define funct3_SLLIW 0b1

#define funct3_SLLW 0b1

#define funct3_SLT 0b10

#define funct3_SLTI 0b10

#define funct3_SLTIU 0b11

#define funct3_SLTU 0b11

#define funct3_SRA 0b101

#define funct3_SRAI 0b101

#define funct3_SRAIW 0b101

#define funct3_SRAW 0b101

#define funct3_SRL 0b101

#define funct3_SRLI 0b101

#define funct3_SRLIW 0b101

#define funct3_SRLW 0b101

#define funct3_SUB 0b0

#define funct3_SUBW 0b0

#define funct3_SW 0b10

#define funct3_XOR 0b100

#define funct3_XORI 0b100

#define funct5_AMOADD 0b0

#define funct5_AMOAND 0b1100

#define funct5_AMOMAX 0b10100

#define funct5_AMOMAXU 0b11100

#define funct5_AMOMIN 0b10000

#define funct5_AMOMINU 0b11000

#define funct5_AMOOR 0b1000

#define funct5_AMOSWAP 0b1

#define funct5_AMOXOR 0b100

#define funct5_LR 0b10

#define funct5_SC 0b11

#define funct6_SLLI 0b0

#define funct6_SRAI 0b10000

#define funct6_SRLI 0b0

#define funct7_ADD 0b0

#define funct7_ADDW 0b0

#define funct7_AND 0b0

#define funct7_DIV 0b1

#define funct7_DIVU 0b1

#define funct7_DIVUW 0b1

#define funct7_DIVW 0b1

#define funct7_MUL 0b1

#define funct7_MULH 0b1

#define funct7_MULHSU 0b1

#define funct7_MULHU 0b1

#define funct7_MULW 0b1

#define funct7_OR 0b0

#define funct7_REM 0b1

#define funct7_REMU 0b1

#define funct7_REMUW 0b1

#define funct7_REMW 0b1

#define funct7_SFENCE_VMA 0b1001

#define funct7_SLL 0b0

#define funct7_SLLIW 0b0

#define funct7_SLLW 0b0

#define funct7_SLT 0b0

#define funct7_SLTU 0b0

#define funct7_SRA 0b100000

#define funct7_SRAIW 0b100000

#define funct7_SRAW 0b100000

#define funct7_SRL 0b0

#define funct7_SRLIW 0b0

#define funct7_SRLW 0b0

#define funct7_SUB 0b100000

#define funct7_SUBW 0b100000

#define funct7_XOR 0b0

bool isValidA(InstructionA inst) {
    switch (inst.kind) {
        case K_InvalidA: {
            return false;
        }
        default: {
            return true;
        }
    }
}

bool isValidA64(InstructionA64 inst) {
    switch (inst.kind) {
        case K_InvalidA64: {
            return false;
        }
        default: {
            return true;
        }
    }
}

bool isValidCSR(InstructionCSR inst) {
    switch (inst.kind) {
        case K_InvalidCSR: {
            return false;
        }
        default: {
            return true;
        }
    }
}

bool isValidI(InstructionI inst) {
    switch (inst.kind) {
        case K_InvalidI: {
            return false;
        }
        default: {
            return true;
        }
    }
}

bool isValidI64(InstructionI64 inst) {
    switch (inst.kind) {
        case K_InvalidI64: {
            return false;
        }
        default: {
            return true;
        }
    }
}

bool isValidM(InstructionM inst) {
    switch (inst.kind) {
        case K_InvalidM: {
            return false;
        }
        default: {
            return true;
        }
    }
}

bool isValidM64(InstructionM64 inst) {
    switch (inst.kind) {
        case K_InvalidM64: {
            return false;
        }
        default: {
            return true;
        }
    }
}

#define opcode_AMO 0b101111

#define opcode_AUIPC 0b10111

#define opcode_BRANCH 0b1100011

#define opcode_JAL 0b1101111

#define opcode_JALR 0b1100111

#define opcode_LOAD 0b11

#define opcode_LOAD_FP 0b111

#define opcode_LUI 0b110111

#define opcode_MADD 0b1000011

#define opcode_MISC_MEM 0b1111

#define opcode_MSUB 0b1000111

#define opcode_NMADD 0b1001111

#define opcode_NMSUB 0b1001011

#define opcode_OP 0b110011

#define opcode_OP_32 0b111011

#define opcode_OP_FP 0b1010011

#define opcode_OP_IMM 0b10011

#define opcode_OP_IMM_32 0b11011

#define opcode_STORE 0b100011

#define opcode_STORE_FP 0b100111

#define opcode_SYSTEM 0b1110011

bool supportsA(InstructionSet arg_0__) {
    switch (arg_0__) {
        case RV32I:
            return false;
        case RV32IM:
            return false;
        case RV64I:
            return false;
        case RV64IM:
            return false;
        default:
            return true;
    }
}

bool supportsM(InstructionSet arg_0__) {
    switch (arg_0__) {
        case RV32I:
            return false;
        case RV32IA:
            return false;
        case RV64I:
            return false;
        case RV64IA:
            return false;
        default:
            return true;
    }
}

Instruction decode(InstructionSet iset, int inst) {
    int aqrl = bitSlice(inst, 0b11001, 0b11011);
    int funct5 = bitSlice(inst, 0b11011, 0b100000);
    int zimm = bitSlice(inst, 0b1111, 0b10100);
    int funct6 = bitSlice(inst, 0b11010, 0b100000);
    int shamtHi = bitSlice(inst, 0b11001, 0b11010);
    bool shamtHiTest = shamtHi == 0b0 || bitwidth(iset) == 0b1000000;
    int shamt6 = bitSlice(inst, 0b10100, 0b11010);
    int shamt5 = bitSlice(inst, 0b10100, 0b11001);
    int sbimm12 = signExtend(0b1101, bitSlice(inst, 0b11111, 0b100000) << 0b1100 | bitSlice(inst, 0b11001, 0b11111) << 0b101 | bitSlice(inst, 0b1000, 0b1100) << 0b1 | bitSlice(inst, 0b111, 0b1000) << 0b1011);
    int simm12 = signExtend(0b1100, bitSlice(inst, 0b11001, 0b100000) << 0b101 | bitSlice(inst, 0b111, 0b1100));
    int csr12 = bitSlice(inst, 0b10100, 0b100000);
    int oimm12 = signExtend(0b1100, bitSlice(inst, 0b10100, 0b100000));
    int imm12 = signExtend(0b1100, bitSlice(inst, 0b10100, 0b100000));
    int jimm20 = signExtend(0b10101, bitSlice(inst, 0b11111, 0b100000) << 0b10100 | bitSlice(inst, 0b10101, 0b11111) << 0b1 | bitSlice(inst, 0b10100, 0b10101) << 0b1011 | bitSlice(inst, 0b1100, 0b10100) << 0b1100);
    int oimm20 = signExtend(0b100000, bitSlice(inst, 0b1100, 0b100000) << 0b1100);
    int imm20 = signExtend(0b100000, bitSlice(inst, 0b1100, 0b100000) << 0b1100);
    int msb4 = bitSlice(inst, 0b11100, 0b100000);
    int pred = bitSlice(inst, 0b11000, 0b11100);
    int succ = bitSlice(inst, 0b10100, 0b11000);
    int rs2 = bitSlice(inst, 0b10100, 0b11001);
    int rs1 = bitSlice(inst, 0b1111, 0b10100);
    int rd = bitSlice(inst, 0b111, 0b1100);
    int funct12 = bitSlice(inst, 0b10100, 0b100000);
    int funct7 = bitSlice(inst, 0b11001, 0b100000);
    int funct3 = bitSlice(inst, 0b1100, 0b1111);
    int opcode = bitSlice(inst, 0b0, 0b111);
    InstructionI decodeI = ((opcode == opcode_LOAD && funct3 == funct3_LB)
        ? Lb(rd, rs1, oimm12)
        : ((opcode == opcode_LOAD && funct3 == funct3_LH)
            ? Lh(rd, rs1, oimm12)
            : ((opcode == opcode_LOAD && funct3 == funct3_LW)
                ? Lw(rd, rs1, oimm12)
                : ((opcode == opcode_LOAD && funct3 == funct3_LBU)
                    ? Lbu(rd, rs1, oimm12)
                    : ((opcode == opcode_LOAD && funct3 == funct3_LHU)
                        ? Lhu(rd, rs1, oimm12)
                        : ((opcode == opcode_MISC_MEM && rd == 0b0 && funct3 == funct3_FENCE && rs1 == 0b0 && msb4 == 0b0)
                            ? Fence(pred, succ)
                            : ((opcode == opcode_MISC_MEM && rd == 0b0 && funct3 == funct3_FENCE_I && rs1 == 0b0 && imm12 == 0b0)
                                ? Fence_i()
                                : ((opcode == opcode_OP_IMM && funct3 == funct3_ADDI)
                                    ? Addi(rd, rs1, imm12)
                                    : ((opcode == opcode_OP_IMM && funct3 == funct3_SLTI)
                                        ? Slti(rd, rs1, imm12)
                                        : ((opcode == opcode_OP_IMM && funct3 == funct3_SLTIU)
                                            ? Sltiu(rd, rs1, imm12)
                                            : ((opcode == opcode_OP_IMM && funct3 == funct3_XORI)
                                                ? Xori(rd, rs1, imm12)
                                                : ((opcode == opcode_OP_IMM && funct3 == funct3_ORI)
                                                    ? Ori(rd, rs1, imm12)
                                                    : ((opcode == opcode_OP_IMM && funct3 == funct3_ANDI)
                                                        ? Andi(rd, rs1, imm12)
                                                        : ((opcode == opcode_OP_IMM && funct3 == funct3_SLLI && funct6 == funct6_SLLI && shamtHiTest)
                                                            ? Slli(rd, rs1, shamt6)
                                                            : ((opcode == opcode_OP_IMM && funct3 == funct3_SRLI && funct6 == funct6_SRLI && shamtHiTest)
                                                                ? Srli(rd, rs1, shamt6)
                                                                : ((opcode == opcode_OP_IMM && funct3 == funct3_SRAI && funct6 == funct6_SRAI && shamtHiTest)
                                                                    ? Srai(rd, rs1, shamt6)
                                                                    : ((opcode == opcode_AUIPC)
                                                                        ? Auipc(rd, oimm20)
                                                                        : ((opcode == opcode_STORE && funct3 == funct3_SB)
                                                                            ? Sb(rs1, rs2, simm12)
                                                                            : ((opcode == opcode_STORE && funct3 == funct3_SH)
                                                                                ? Sh(rs1, rs2, simm12)
                                                                                : ((opcode == opcode_STORE && funct3 == funct3_SW)
                                                                                    ? Sw(rs1, rs2, simm12)
                                                                                    : ((opcode == opcode_OP && funct3 == funct3_ADD && funct7 == funct7_ADD)
                                                                                        ? Add(rd, rs1, rs2)
                                                                                        : ((opcode == opcode_OP && funct3 == funct3_SUB && funct7 == funct7_SUB)
                                                                                            ? Sub(rd, rs1, rs2)
                                                                                            : ((opcode == opcode_OP && funct3 == funct3_SLL && funct7 == funct7_SLL)
                                                                                                ? Sll(rd, rs1, rs2)
                                                                                                : ((opcode == opcode_OP && funct3 == funct3_SLT && funct7 == funct7_SLT)
                                                                                                    ? Slt(rd, rs1, rs2)
                                                                                                    : ((opcode == opcode_OP && funct3 == funct3_SLTU && funct7 == funct7_SLTU)
                                                                                                        ? Sltu(rd, rs1, rs2)
                                                                                                        : ((opcode == opcode_OP && funct3 == funct3_XOR && funct7 == funct7_XOR)
                                                                                                            ? Xor(rd, rs1, rs2)
                                                                                                            : ((opcode == opcode_OP && funct3 == funct3_SRL && funct7 == funct7_SRL)
                                                                                                                ? Srl(rd, rs1, rs2)
                                                                                                                : ((opcode == opcode_OP && funct3 == funct3_SRA && funct7 == funct7_SRA)
                                                                                                                    ? Sra(rd, rs1, rs2)
                                                                                                                    : ((opcode == opcode_OP && funct3 == funct3_OR && funct7 == funct7_OR)
                                                                                                                        ? Or(rd, rs1, rs2)
                                                                                                                        : ((opcode == opcode_OP && funct3 == funct3_AND && funct7 == funct7_AND)
                                                                                                                            ? And(rd, rs1, rs2)
                                                                                                                            : ((opcode == opcode_LUI)
                                                                                                                                ? Lui(rd, imm20)
                                                                                                                                : ((opcode == opcode_BRANCH && funct3 == funct3_BEQ)
                                                                                                                                    ? Beq(rs1, rs2, sbimm12)
                                                                                                                                    : ((opcode == opcode_BRANCH && funct3 == funct3_BNE)
                                                                                                                                        ? Bne(rs1, rs2, sbimm12)
                                                                                                                                        : ((opcode == opcode_BRANCH && funct3 == funct3_BLT)
                                                                                                                                            ? Blt(rs1, rs2, sbimm12)
                                                                                                                                            : ((opcode == opcode_BRANCH && funct3 == funct3_BGE)
                                                                                                                                                ? Bge(rs1, rs2, sbimm12)
                                                                                                                                                : ((opcode == opcode_BRANCH && funct3 == funct3_BLTU)
                                                                                                                                                    ? Bltu(rs1, rs2, sbimm12)
                                                                                                                                                    : ((opcode == opcode_BRANCH && funct3 == funct3_BGEU)
                                                                                                                                                        ? Bgeu(rs1, rs2, sbimm12)
                                                                                                                                                        : ((opcode == opcode_JALR)
                                                                                                                                                            ? Jalr(rd, rs1, oimm12)
                                                                                                                                                            : ((opcode == opcode_JAL)
                                                                                                                                                                ? Jal(rd, jimm20)
                                                                                                                                                                : InvalidI())))))))))))))))))))))))))))))))))))))));
    InstructionM decodeM = ((opcode == opcode_OP && funct3 == funct3_MUL && funct7 == funct7_MUL)
        ? Mul(rd, rs1, rs2)
        : ((opcode == opcode_OP && funct3 == funct3_MULH && funct7 == funct7_MULH)
            ? Mulh(rd, rs1, rs2)
            : ((opcode == opcode_OP && funct3 == funct3_MULHSU && funct7 == funct7_MULHSU)
                ? Mulhsu(rd, rs1, rs2)
                : ((opcode == opcode_OP && funct3 == funct3_MULHU && funct7 == funct7_MULHU)
                    ? Mulhu(rd, rs1, rs2)
                    : ((opcode == opcode_OP && funct3 == funct3_DIV && funct7 == funct7_DIV)
                        ? Div(rd, rs1, rs2)
                        : ((opcode == opcode_OP && funct3 == funct3_DIVU && funct7 == funct7_DIVU)
                            ? Divu(rd, rs1, rs2)
                            : ((opcode == opcode_OP && funct3 == funct3_REM && funct7 == funct7_REM)
                                ? Rem(rd, rs1, rs2)
                                : ((opcode == opcode_OP && funct3 == funct3_REMU && funct7 == funct7_REMU)
                                    ? Remu(rd, rs1, rs2)
                                    : InvalidM()))))))));
    InstructionA decodeA = ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_LR && rs2 == 0b0)
        ? Lr_w(rd, rs1, aqrl)
        : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_SC)
            ? Sc_w(rd, rs1, rs2, aqrl)
            : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOSWAP)
                ? Amoswap_w(rd, rs1, rs2, aqrl)
                : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOADD)
                    ? Amoadd_w(rd, rs1, rs2, aqrl)
                    : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOXOR)
                        ? Amoxor_w(rd, rs1, rs2, aqrl)
                        : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOAND)
                            ? Amoand_w(rd, rs1, rs2, aqrl)
                            : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOOR)
                                ? Amoor_w(rd, rs1, rs2, aqrl)
                                : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOMIN)
                                    ? Amomin_w(rd, rs1, rs2, aqrl)
                                    : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOMAX)
                                        ? Amomax_w(rd, rs1, rs2, aqrl)
                                        : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOMINU)
                                            ? Amominu_w(rd, rs1, rs2, aqrl)
                                            : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOMAXU)
                                                ? Amomaxu_w(rd, rs1, rs2, aqrl)
                                                : InvalidA())))))))))));
    InstructionI64 decodeI64 = ((opcode == opcode_LOAD && funct3 == funct3_LD)
        ? Ld(rd, rs1, oimm12)
        : ((opcode == opcode_LOAD && funct3 == funct3_LWU)
            ? Lwu(rd, rs1, oimm12)
            : ((opcode == opcode_OP_IMM_32 && funct3 == funct3_ADDIW)
                ? Addiw(rd, rs1, imm12)
                : ((opcode == opcode_OP_IMM_32 && funct3 == funct3_SLLIW && funct7 == funct7_SLLIW)
                    ? Slliw(rd, rs1, shamt5)
                    : ((opcode == opcode_OP_IMM_32 && funct3 == funct3_SRLIW && funct7 == funct7_SRLIW)
                        ? Srliw(rd, rs1, shamt5)
                        : ((opcode == opcode_OP_IMM_32 && funct3 == funct3_SRAIW && funct7 == funct7_SRAIW)
                            ? Sraiw(rd, rs1, shamt5)
                            : ((opcode == opcode_STORE && funct3 == funct3_SD)
                                ? Sd(rs1, rs2, simm12)
                                : ((opcode == opcode_OP_32 && funct3 == funct3_ADDW && funct7 == funct7_ADDW)
                                    ? Addw(rd, rs1, rs2)
                                    : ((opcode == opcode_OP_32 && funct3 == funct3_SUBW && funct7 == funct7_SUBW)
                                        ? Subw(rd, rs1, rs2)
                                        : ((opcode == opcode_OP_32 && funct3 == funct3_SLLW && funct7 == funct7_SLLW)
                                            ? Sllw(rd, rs1, rs2)
                                            : ((opcode == opcode_OP_32 && funct3 == funct3_SRLW && funct7 == funct7_SRLW)
                                                ? Srlw(rd, rs1, rs2)
                                                : ((opcode == opcode_OP_32 && funct3 == funct3_SRAW && funct7 == funct7_SRAW)
                                                    ? Sraw(rd, rs1, rs2)
                                                    : InvalidI64()))))))))))));
    InstructionM64 decodeM64 = ((opcode == opcode_OP_32 && funct3 == funct3_MULW && funct7 == funct7_MULW)
        ? Mulw(rd, rs1, rs2)
        : ((opcode == opcode_OP_32 && funct3 == funct3_DIVW && funct7 == funct7_DIVW)
            ? Divw(rd, rs1, rs2)
            : ((opcode == opcode_OP_32 && funct3 == funct3_DIVUW && funct7 == funct7_DIVUW)
                ? Divuw(rd, rs1, rs2)
                : ((opcode == opcode_OP_32 && funct3 == funct3_REMW && funct7 == funct7_REMW)
                    ? Remw(rd, rs1, rs2)
                    : ((opcode == opcode_OP_32 && funct3 == funct3_REMUW && funct7 == funct7_REMUW)
                        ? Remuw(rd, rs1, rs2)
                        : InvalidM64())))));
    InstructionA64 decodeA64 = ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_LR && rs2 == 0b0)
        ? Lr_d(rd, rs1, aqrl)
        : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_SC)
            ? Sc_d(rd, rs1, rs2, aqrl)
            : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOSWAP)
                ? Amoswap_d(rd, rs1, rs2, aqrl)
                : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOADD)
                    ? Amoadd_d(rd, rs1, rs2, aqrl)
                    : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOXOR)
                        ? Amoxor_d(rd, rs1, rs2, aqrl)
                        : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOAND)
                            ? Amoand_d(rd, rs1, rs2, aqrl)
                            : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOOR)
                                ? Amoor_d(rd, rs1, rs2, aqrl)
                                : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOMIN)
                                    ? Amomin_d(rd, rs1, rs2, aqrl)
                                    : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOMAX)
                                        ? Amomax_d(rd, rs1, rs2, aqrl)
                                        : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOMINU)
                                            ? Amominu_d(rd, rs1, rs2, aqrl)
                                            : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOMAXU)
                                                ? Amomaxu_d(rd, rs1, rs2, aqrl)
                                                : InvalidA64())))))))))));
    InstructionCSR decodeCSR = ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && funct7 == funct7_SFENCE_VMA)
        ? Sfence_vma(rs1, rs2)
        : ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && rs1 == 0b0 && funct12 == funct12_ECALL)
            ? Ecall()
            : ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && rs1 == 0b0 && funct12 == funct12_EBREAK)
                ? Ebreak()
                : ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && rs1 == 0b0 && funct12 == funct12_URET)
                    ? Uret()
                    : ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && rs1 == 0b0 && funct12 == funct12_SRET)
                        ? Sret()
                        : ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && rs1 == 0b0 && funct12 == funct12_MRET)
                            ? Mret()
                            : ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && rs1 == 0b0 && funct12 == funct12_WFI)
                                ? Wfi()
                                : ((opcode == opcode_SYSTEM && funct3 == funct3_CSRRW)
                                    ? Csrrw(rd, rs1, csr12)
                                    : ((opcode == opcode_SYSTEM && funct3 == funct3_CSRRS)
                                        ? Csrrs(rd, rs1, csr12)
                                        : ((opcode == opcode_SYSTEM && funct3 == funct3_CSRRC)
                                            ? Csrrc(rd, rs1, csr12)
                                            : ((opcode == opcode_SYSTEM && funct3 == funct3_CSRRWI)
                                                ? Csrrwi(rd, zimm, csr12)
                                                : ((opcode == opcode_SYSTEM && funct3 == funct3_CSRRSI)
                                                    ? Csrrsi(rd, zimm, csr12)
                                                    : ((opcode == opcode_SYSTEM && funct3 == funct3_CSRRCI)
                                                        ? Csrrci(rd, zimm, csr12)
                                                        : InvalidCSR())))))))))))));
    InstructionList resultCSR = ((isValidCSR(decodeCSR))
        ? singleton_instruction_list(CSRInstruction(decodeCSR))
        : empty_instruction_list());
    InstructionList resultA64 = ((isValidA64(decodeA64))
        ? singleton_instruction_list(A64Instruction(decodeA64))
        : empty_instruction_list());
    InstructionList resultM64 = ((isValidM64(decodeM64))
        ? singleton_instruction_list(M64Instruction(decodeM64))
        : empty_instruction_list());
    InstructionList resultI64 = ((isValidI64(decodeI64))
        ? singleton_instruction_list(I64Instruction(decodeI64))
        : empty_instruction_list());
    InstructionList resultA = ((isValidA(decodeA))
        ? singleton_instruction_list(AInstruction(decodeA))
        : empty_instruction_list());
    InstructionList resultM = ((isValidM(decodeM))
        ? singleton_instruction_list(MInstruction(decodeM))
        : empty_instruction_list());
    InstructionList resultI = ((isValidI(decodeI))
        ? singleton_instruction_list(IInstruction(decodeI))
        : empty_instruction_list());
    InstructionList results = concat_instruction_list(resultI, concat_instruction_list(((supportsM(iset))
        ? resultM
        : empty_instruction_list()), concat_instruction_list(((supportsA(iset))
        ? resultA
        : empty_instruction_list()), concat_instruction_list(((bitwidth(iset) == 0b1000000)
        ? resultI64
        : empty_instruction_list()), concat_instruction_list(((bitwidth(iset) == 0b1000000 && supportsM(iset))
        ? resultM64
        : empty_instruction_list()), concat_instruction_list(((bitwidth(iset) == 0b1000000 && supportsA(iset))
        ? resultA64
        : empty_instruction_list()), resultCSR))))));
    if (results.size > 0b1) {
        return InvalidInstruction(inst);
    } else {
        return instruction_list_head_default(results, InvalidInstruction(inst));
    }
}

