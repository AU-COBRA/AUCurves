This directory contains the plugin portion of the rewriter.  There are
some examples in
[`src/Rewriter/Rewriter/Examples.v`](../../Rewriter/Examples.v).

As Ltac cannot emit `Inductive` declarations, nor emit `Global
Strategy` commands that persist after the proof, we must code these
parts in OCaml.  Additionally, for convenience of use, we also script
the sequencing of Ltac commands with these two parts.

There are five steps to buidling the rewriter package:

1. Given a user-specified tuple of rewrite rules `rules` with type
   `rules_ty`, invoke typeclass resolution (or the tactic
   `make_rules_proofs_with_args`) on a goal of the form
   `lib:@rewriter.rules_proofs_with_args.type rules_ty rules` to get a
   term of the form `existT _ _ rules_proofs` (ignoring casts), from
   which we extract `rules_proofs`.

2. Given the computed `rules_proofs` of type
   `@Rewriter.Util.PrimitiveHList.hlist (@snd bool Prop) rules_ty` and
   optionally (default: `lib:core.bool.false`) a user-specified term
   `extra` (of type `extra_ty`) containing extra identifiers to appear
   in the inductive of valid identifiers, invoke typeclass resolution
   (or the tactic `make_scraped_data_with_args`) on a goal of the form
   `lib:@rewriter.scraped_data_with_args.type rules_ty rules_proofs
   extra_ty extra` to get a term whose `hnf` we will call
   `scraped_data`.

3. We must now emit the four inductive types.  If the user does not
   give us names for these types, we will pick the first available
   global names away from "base", "ident", "pattern_ident", and
   "raw_ident".  Since there is no direct translation between
   Gallina/Ltac and the inductive declaration expected by the kernel,
   I had to pick an encoding within a single term to encode both the
   names and types of constructors.  We only support inductives where
   all parameters are treated as indices (and therefore repeated in
   each of the constructors).  The encoding I picked was the Church
   encoding (roughly, the eliminator which is dependent over indices
   but not the element of the type family itself), where each case of
   the eliminator has a binder name corresponding to the constructor.
   (Actually, we get the name for each constructor by taking the first
   available global name away from each binder name.)  For example:

   - the encoding of `Coq.Init.Datatypes.nat` is
     `forall (nat : Set) (O : nat) (S : nat -> nat), nat`,

   - the encoding of `Coq.Init.Datatypes.list` is
     `forall (list : Type -> Type) (nil : forall T, list T) (cons : forall T, T -> list T -> list T), forall T, list T`,

   - and the encoding of `Coq.Init.Logic.eq` is
     `forall (eq : forall A, A -> A -> Prop) (eq_refl : forall A a, eq A a a), forall A a b, eq A a b`

   Nominally, the user/tactic creating the eliminator is responsible
   for all universe constraints, but this is only because I could not
   figure out how to infer the correct universe constraints.  Ideally,
   the plugin code emitting the inductive type would infer necessary
   universe constraints.

   The first inductive types we emit is `base`, whose Church-encoding
   is generated by typeclass resolution (or by the tactic
   `make_base_elim_with_args`) on a goal of the form
   `lib:@rewriter.base_elim_with_args.type scraped_data`.

   The other three take the same form: for `i` being each of `ident`,
   `pattern_ident`, and `raw_ident`, emit inductive `${i}` whose
   Church-encoding is generated by typeclass resolution (or by the
   tactic `make_${i}_elim_with_args`) on a goal of the form
   `lib:@rewriter.${i}_elim_with_args.type scraped_data base`.

4. Now we build the verified rewriter package.  Given the computed
   `scraped_data`, `base`, `ident`, `pattern_ident`, `raw_ident`,
   `rules_ty`, and `rules_proofs`, and given a user-given name `n` and
   optionally a user-given term `var_like_idents` (default:
   `lib:@rewriter.ident_list.nil`) of var-like identifiers, optionally
   a user-given boolean `include_interp` (default:
   `lib:core.bool.false`) determining whether or not to include
   unfolding rules in the rewriter, and optionally a user-given
   boolean `skip_early_reduction` (default: `lib:core.bool.false`)
   determining whether or not we skip pre-reducing the rewriter, we
   invoke typeclass resolution (or the tactic
   `make_verified_rewriter_with_args`) on a goal of the form
   `lib:@rewriter.verified_rewriter_with_args.type scraped_data
   var_like_idents base ident raw_ident pattern_ident include_interp
   skip_early_reduction rules_ty rules_proofs` to get a term which we
   add as a constant to the global namespace under the name `n`.
   Importantly, this constant MUST be transparent (unfoldable), and we
   MUST correctly emit side-effects generated by
   `transparent_abstract` during the typeclass resolution / tactic
   invocation which generated this constant.  Henceforth, this
   constant will be known as `verified_rewriter`.

5. Finally, we must emit the `Global Strategy` command.  The `hnf` of
   the `verified_rewriter` constant will have the form `{|
   Rewriter.Rewriter.ProofsCommon.Compilers.RewriteRules.GoalType.exprInfo
   := {| Rewriter.Language.Language.Compilers.Classes.base_interp :=
   base_interp ;
   Rewriter.Language.Language.Compilers.Classes.ident_interp :=
   ident_interp |} |}`.  (Note that we have elided some fields.)  If
   `base_interp` (or `ident_interp`) is not a global reference, peel
   off any application structure.  Call the global reference at the
   head of the application structure `base_interp_head` (respectively,
   `ident_interp_head`).  Emit `Global Strategy -1000
   [base_interp_head ident_interp_head]`.

(Ideally, there would be a way to run step 5 in the middle of tactic
execution.  Currently the plugin fakes this by exposing a proof-local
`Local Strategy` tactic, which is called from Ltac, and then running
`Global Strategy` in step 5.)

Note that steps 1 and 2 merely build terms, and do not emit anything
into the global environment.  Step 3 emits four inductive types, step
4 explicitly emits one constant (and implicitly emits many more via
transparent_abstract), and step 5 emits no constants but updates the
strategy of two constants emitted by `transparent_abstract` in step 4.


In pseudo-code that results from freely mixing OCaml, Ltac, and elpi
syntax, the code I want looks something like:

```
Require Import Rewriter.Util.plugins.RewriterBuildRegistry.

let rec projT2_skip_cast c =
  match Constr.kind c with
  | Cast (c, _, _) -> projT2_skip_cast c
  | App (_existT, [|_tA; _tP; _proj1; proj2|]) -> proj2
  | _ -> fail 0 "Not an existT:" c

let rules_ty_of_rules_proofs rules_proofs =
  let rules_proofs_ty = Typing.type_of rules_proofs in
  match Constr.kind rules_proofs_ty with
  | App (_hlist, [|_A; _snd; rules_ty|]) -> rules_ty
  | _ -> fail 0 "Invalid type for rules_proofs: " rules_proofs_ty

let rec indc-of-body ind_body =
  let cname := match ind_body with forall cname : _, _ => cname end in
  let cname := fresh cname in
  match ind_body with
  | ?cty -> ?rest_body =>
    constructor cname cty :: indc-of-body rest_body
  | _ => []

let indt-decl-of-elim (n : name) (elim : term) =
  match (eval hnf in elim) with
  | forall ind_name : ?ind_ty, ?ind_body =>
      coq.elaborate-indt-decl
        (inductive n <magic int value???> {{ ind_ty }} ind_name\
           indc-of-body ind_body)
  end

let head c =
  match Constr.kind c with
  | App (f, _) -> f
  | _ -> c

let get_idents_for_strategy_of_package (package : term) =
  let package : term = (eval hnf in package) in
  let exprInfo : term = match Constr.kind package with
    | App (_build, args) -> args.(0)
    | _ -> fail 0 "Invalid hnf of verified rewriter package:" package
  in
  let exprInfo : term = (eval hnf in exprInfo) in
  match Constr.kind exprInfo with
  | App (_build, [|base; ident; base_interp; ident_interp|]) ->
    [head base_interp; head ident_interp]
  | _ -> fail 0 "Invalid hnf of exprInfo:" exprInfo

let scrape_data (rules : term) (extra : term) =
  let rules_ty : term = Typing.type_of rules in
  let rules_proofs : term = constr:(_ : lib:@rewriter.rules_proofs_with_args.type rules_ty rules) in (* by TC resolution *)
  let rules_proofs : term = projT2_skip_cast rules_proofs in

  let rules_ty : term = rules_ty_of_rules_proofs rules_proofs in
  let extra_ty : term = Typing.type_of extra in

  let scraped_data : term = constr:(_ : lib:@rewriter.scraped_data_with_args.type rules_ty rules_proofs extra_ty extra) (* by TC resolution *) in
  let scraped_data : term = (eval hnf in scraped_data) in

  (rules_ty, scraped_data)


let rewriter_emit_inductives (scraped_data : term) (base_name : name) (ident_name : name) (pattern_ident_name : name) (raw_ident_name : name) =
  let base_elim : term = constr:(_ : lib:@rewriter.base_elim_with_args.type scraped_data) (* by TC resolution *) in
  let base : term = coq.env.add-indt (indt-decl-of-elim base_name base_elim) in

  let ident_elim : term = constr:(_ : lib:@rewriter.ident_elim_with_args.type scraped_data base) (* by TC resolution *) in
  let ident : term = coq.env.add-indt (indt-decl-of-elim ident_name ident_elim) in

  let pattern_ident_elim : term = constr:(_ : lib:@rewriter.pattern_ident_elim_with_args.type scraped_data base) (* by TC resolution *) in
  let pattern_ident : term = coq.env.add-indt (indt-decl-of-elim pattern_ident_name pattern_ident_elim) in

  let raw_ident_elim : term = constr:(_ : lib:@rewriter.raw_ident_elim_with_args.type scraped_data base) (* by TC resolution *) in
  let raw_ident : term = coq.env.add-indt (indt-decl-of-elim raw_ident_name raw_ident_elim) in

  (base, ident, pattern_ident, raw_ident)


let build_rewriter_full (n : name) (rules : term) (include_interp : term) (skip_early_reduction : term) (var_like_idents : term) (extra : term) =
  let (rules_ty, scraped_data) = scrape_data rules extra in
  let (base, ident, pattern_ident, raw_ident) = rewriter_emit_inductives scraped_data (fresh "base") (fresh "ident") (fresh "pattern_ident") (fresh "raw_ident") in

  (* N.B. this next step has transparent_abstract in TC resolution; the names must be preserved globally *)
  let verified_rewriter : term = constr:(_ : lib:@rewriter.verified_rewriter_with_args.type scraped_data var_like_idents base ident raw_ident pattern_ident include_interp skip_early_reduction rules_ty rules_proofs) in
  let verified_rewriter : term = coq.env.add-const n verified_rewriter _ Transparent Global in

  let idents_from_package : term list = get_idents_for_strategy_of_package verified_rewriter in
  global_set_strategy (-1000) idents_from_package


let build_rewriter (n : name) (rules : term) =
  build_rewriter_common n rules (lib:@core.bool.false) (lib:@rewriter.ident_list.nil) (lib:@core.bool.false)
let build_rewriter_with_interp (n : name) (rules : term) =
  build_rewriter_common n rules (lib:@core.bool.true) (lib:@rewriter.ident_list.nil) (lib:@core.bool.false)
let build_rewriter_with_vars (n : name) (rules : term) (var_like_idents : term) =
  build_rewriter_common n rules (lib:@core.bool.false) var_like_idents (lib:@core.bool.false)
let build_rewriter_with_interp_with_vars (n : name) (rules : term) (var_like_idents : term) =
  build_rewriter_common n rules (lib:@core.bool.true) var_like_idents (lib:@core.bool.false)
let build_rewriter_with_extra (n : name) (rules : term) (extra:term) =
  build_rewriter_common n rules (lib:@core.bool.false) (lib:@rewriter.ident_list.nil) extra
let build_rewriter_with_interp_with_extra (n : name) (rules : term) (extra:term) =
  build_rewriter_common n rules (lib:@core.bool.true) (lib:@rewriter.ident_list.nil) extra
let build_rewriter_with_vars_with_extra (n : name) (rules : term) (var_like_idents : term) (extra:term) =
  build_rewriter_common n rules (lib:@core.bool.false) var_like_idents extra
let build_rewriter_with_interp_with_vars_with_extra (n : name) (rules : term) (var_like_idents : term) (extra:term) =
  build_rewriter_common n rules (lib:@core.bool.true) var_like_idents extra
```
